# Canard bootstrap interpreter | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# Basic syntax used in this file is:

# | 1. Address assertion: @!address. Dies unless the next byte will be emitted at
#      the given address. I use these to verify/document the code.
#   2. Address displacement: @address. Inserts null bytes until the given address
#      is reached.
#   3. /n/byte - byte repeated n times (n is decimal, not hex).

# That's about it. The rest is just binary data written verbatim in hex (no
# prefix), octal (o prefix), binary (- prefix), or ASCII (' prefix).

#   Conventions.
#   The most consistent convention I use is encoding the ModR/M and SIB bytes in
#   octal rather than hex. This better reflects its structure; so, for instance:

#   | movq %rax, %rbx             # copy %rax into %rbx
#     488b o330
#      | |  |||
#      | |  ||+-- r/m = 000, %rax
#      | |  |+--- reg = 011, %rbx
#      | |  +---- mod = 11, reg/reg
#      | +------- opcode = 8b (move right -> left)
#      +--------- REX.W prefix (0100 = REX, 1000 = WRXB)

#   I avoid using any prefix aside from REX.W, which is encoded as 48 and is a
#   fairly good giveaway that something is an opcode. Immediate operands usually
#   have spaces between bytes to make it easier to parse the little-endian
#   encoding:

#   | push $0x400010              # push a 32-bit immediate
#     68 10 00 40 00
#      |  |
#      |  +-- immediate: little-endian, so bytes are reversed
#      +----- opcode: 68 = push 32-bit immediate

# ELF header.
# See elf(5) for details about what this is made of.

# Elf64_Ehdr                    # e_ident
@!00 7f 'ELF                    #   ELF magic
@!04 02                         #   64-bit binary
@!05 01                         #   Two's complement little-endian
@!06 01                         #   Current ELF version
@!07 00                         #   System V UNIX ABI

@!08 00                         #   ABI version
@!09 /7/00                      # padding; end

@!10 02 00                      # e_type    = Executable file
@!12 3e 00                      # e_machine = x86-64
@!14 01 00 00 00                # e_version = current version
@!18 78 00 40 00 /4/00          # e_entry

@!20 40 00 00 00 /4/00          # e_phoff
@!28 00 00 00 00 /4/00          # e_shoff

@!30 /4/00                      # e_flags
@!34 40 00                      # e_ehsize
@!36 38 00                      # e_phentsize
@!38 01 00                      # e_phnum

@!3a 0000                       # e_shentsize
@!3c 0000                       # e_shnum
@!3e 0000                       # e_shstrndx

@!40
# end

# Elf64_Phdr (rwx image -- this contains code and definitions)
@!40 01 00 00 00                # p_type  = PT_LOAD
@!44 07 00 00 00                # p_flags = PT_R | PT_W | PT_X

@!48 00 00 00 00 /4/00          # p_offset (includes ELF header)
@!50 00 00 40 00 /4/00          # p_vaddr
@!58 00 00 00 00 /4/00          # p_paddr
@!60 00 01 00 00 /4/00          # p_filesz
@!68 00 00 10 00 /4/00          # p_memsz
@!70 00 10 00 00 /4/00          # p_align

@!78
# end

# Core image layout.
# The core image consists of two stacks and a heap. The stacks go in opposite
# directions; the return stack is provided by the host operating system and uses
# the processor's native push/pop instructions. The data stack grows forwards from
# the first free address mapped into the interpreter's address space. The commands
# used to manipulate the data stack are inlined into use sites.

# The heap grows downwards and is used for allocating cons cells and other
# contiguous blocks of memory. Register mapping is:

# | %rsp (register 4) return stack pointer (grows downwards)
#   %rdi (register 7) data stack pointer (grows upwards towards %rsi)
#   %rsi (register 6) heap pointer (grows downwards towards %rdi)

# All other general-purpose registers are available for clobbering. The choices
# for the above registers are not arbitrary; they are chosen to minimize the
# number of spurious SIB bytes and displacements required to access memory. (See
# the Intel Instruction Set Reference for the machine-level exception cases for
# various registers.)

# At the top (high addresses) of the heap is the symbol table, which consists of
# heap-allocated cons cells as more definitions occur. When Canard boots up, it
# immediately invokes the 'main' symbol; this function contains logic for the
# interpreter/REPL. The original value of %rsp (the one that the OS provided) is
# pushed onto the data stack prior to invoking 'main'.

#   Register initialization.
#   Set up these registers to point to useful places. %rsp is provided by the OS,
#   so we don't need to do anything else with it. We set up %rdi and %rsi like
#   this:

#   | +-- 400000   +-- 400078       +-- 40xxxx            +-- 500000
#     V            V                V                     V
#     | ELF header | bootstrap code | data stack ... heap | .... | %rsp stack

#   I'm leaving the data stack lower bound as a variable here because it depends
#   on the amount of bootstrap code that we use. But the idea is the same either
#   way; the data stack begins immediately after the bootstrap logic. In order to
#   make this as automatic as possible, we grab the value from the ELF header. In
#   this case, we want to add 0x400000 to the p_filesz field in the first program
#   header entry; this field is located at 0x400060.

#   Because this number is frequently used, I'm storing it in %rbp during the
#   initialization process.

  @!78 488b o054 o045 60 00 40 00 @!80  # get p_filesz
  @!80 4881 o305      00 00 40 00 @!87  # add p_vaddr to get memory offset

#   At this point %rbp points to the bottom (lowest address) of the data stack.

  @!87 488b o375                # initialize %rdi to bottom of data stack
       48c7 o306 f8 ff 4f 00    # initialize %rsi to top of heap minus 8
       488b o304 48ab @!96      # %rsp -> %rax; stosq to push onto data stack

#   I'm leaving an 8-byte slot open at the top of the heap. This is used to keep
#   track of the current global symbol table cons cell, since it changes every
#   time we define something. This is the only piece of global mutable state
#   maintained by the interpreter (aside from the stacks and heap).

#   At this point the registers are initialized, so we can write to both stacks
#   and to the heap. We need to set up a 'return' into the exit function so that
#   when the main function exits it will die gracefully. First let's push the exit
#   function address onto the return stack:

  @!96 68 92 00 40 00 @!9b

#   Now push the symbol 'main' onto the data stack and call the symbol table. This
#   boots up the interpreter.

#   Symbol encoding.
#   As mentioned in the design documentation, symbols are encoded using a single
#   byte prefix for the length. So 'hello' is encoded as 05 68656c6c6f, a total of
#   six bytes. Unicode is not parsed, though it will work transparently modulo the
#   fact that the byte-length limit is still 255.

#   What we need to do here is encode the symbol 'main. We don't actually need to
#   write it again since it's already present in the symbol table; however, this
#   provides a good functional test of the symbol resolution code so it's worth
#   doing. We can drop the symbol directly into the machine code and just refer to
#   it by absolute address.

#   We can easily drop short symbols directly into machine code by using a
#   mov-immediate into %rax that will be subsequently overwritten. The advantage
#   of doing things this way is that disassemblers won't have to follow jumps to
#   figure out where the instructions are.

  @!9b 48b8 04 'main /3/00 @!a5
  @!a5 48c7 o300 a0 00 40 00 48ab @!ae  # data-push the 'main symbol address

#   Now do a symbol table lookup to get the address. When this returns, we'll have
#   the address of the 'main function on top of the data stack.

#   Before we can do this lookup, however, we need to construct the symbol table.

# Symbol table.
# There are several pieces of machinery involved in creating the symbol table.
# First, the symbol table is ultimately a function composition, which is
# represented in Canard as a linked list of cons cells. So the general form is
# something like this:

# | 4ffff8: 00000000ssssssss
#   ssssssss: e8 xxxxxxxx | e8 yyyyyyyy | e9 zzzzzzzz
#   zzzzzzzz: e8 qqqqqqqq | ... | c3

# Specifically, when executed it will use an x86 CALL to each entry, and when
# examined as a cons tree it will give you each symbol resolver directly. At the
# very end is a RET instruction; the result of this is that if no resolver can
# handle the symbol you pass in, the symbol table just hands you your symbol back.
# In list form, this corresponds to a nil as the final tail.

@!ae 48ff o316    @!b1          # allocate one byte for nil
@!b1 48c6 o006 c3 @!b5          # move the byte c3 to this address

# At this point, the heap looks like this:

# | %rsi -> | c3 | xxxxxxxx xxxxxxxx |

#   Matchers and symbol resolution.
#   Each function in the symbol table composition is a matcher. This means that it
#   uses a calling convention that allows it to operate in conjunction with other
#   matchers in the symbol table. The calling convention is a consequence of the
#   way the symbol table works. For example, here's a matching process:

#   | call resolve_symbol                 <- %rsp is now 'return'
#     resolve_symbol:
#       call first_matcher                <- %rsp is now 'next'
#       call second_matcher               <- %rsp is now 'next'
#       ...
#       ret                               <- %rsp is now 'no match'

#   Matchers are always run in order like this, and their return values are not
#   checked by any conditional. It would appear as though we need to thread some
#   sort of state through the rest of the calls to communicate when a matcher has
#   succeeded. This is not the case, however. Matchers can elect to return early
#   by popping a continuation off of %rsp and then using a RET instruction to
#   return directly to the caller of resolve_symbol:

#   | first_matcher:
#       ...
#       stosq                             <- push result onto data stack
#       pop %rax                          <- discard 'next' continuation
#       ret                               <- invoke 'return' continuation

#   If a matcher fails, it should leave the data stack alone and invoke the 'next'
#   continuation as if nothing had happened:

#   | first_matcher:
#       ...
#       ret                               <- invoke 'next' continuation

#   Constant symbol matcher.
#   This is the first real piece of code that deals with the symbol table. We need
#   to be able to take a symbol and generate machine code to match that symbol
#   exactly. If the symbol does match, we replace the stack top with the symbol's
#   definition.
# Generated by SDoc
