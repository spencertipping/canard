nb[ Canard standard library: list functions | Spencer Tipping ]
nb[ Licensed under the terms of the MIT source code license ]

nb[ Introduction. ]
nb[ This library defines useful list functions, including map, flatmap, filter, append, etc. All traversal goes from right to left, as per the natural cons cell ordering. ]

nb[ Recursive flatmap definition. ]
nb[ This is the :** equivalent of flat-map. It gives you the flexibility to replace one item with many, even within a sublist. Behavior is this: ]

nb[ | :~* [f] :: x y -> :: [] :~ [:~* [f]] :: x y   (lists are singly-mapped) ]
nb[   :~* [f] _      -> :! f _                      (item results are coerced into lists if not already) ]

= ':~* [? [:: [] :~ :: [:~*]] [:! .] :? %1]

nb[ List folds. ]
nb[ These two functions fold up the elements of lists, passing them to a binary function. This function, presumably, returns one value for every two it consumes; but it is free to do other things ]
nb[ as well. ]

nb[ | :/ n [f] :: x y -> f :/ n [f] x y ]
nb[ | :/ n [f] []     -> n ]

= ':/ [? [. ^1 [:/] %1 ^2 [:^]] [^1 [%% 02 []]] :? %2]

nb[ Flatmap definition. ]
nb[ Flat-map is structured just like map. The only difference is that the intermediate results are appended rather than consed. Also, it needs to make a recursive call to itself rather than to the ]
nb[ map function. ]

= ':~ :** @o @/ ':* [':~] @/ ':: [':+] @ ':*

nb[ Recursive map. ]
nb[ Like the regular map function, but distributes over sub-lists recursively. This is primarily useful for editing functions in their list form. ]

nb[ | :** [f] :: x y -> :* [:** [f]] :: x y ]
nb[   :** [f] _      -> f _ ]

nb[ You can use it like this: :** [+ 1] [1 2 [3 4] 5], yielding [2 3 [4 5] 6]. Note that you cannot use this function until map (:*) has been defined. ]

= ':** [? [:* :: [:**]] [.] :? %1]

nb[ Map-function template. ]
nb[ Here is the derivation for flatmap: ]

nb[ | :~ [f] :: x y -> :+ :~ [f] x f y ]
nb[   ^1 [:^]      [f] :: x y  = [f] x y ]
nb[   %% 2 [0 1 0] [f] x y     = [f] x [f] y ]
nb[   ^2 [.]       [f] x [f] y = [f] x f y ]
nb[   :+ :~        [f] x f y   = :+ :~ [f] x f y ]

nb[ Notice, however, that a number of functions here can be replaced to do other things. For instance, the :+ invocation in flatmap can be replaced with ::, at which point the function will be a ]
nb[ regular map. What we really have is a 'map template' that can be specialized in different ways. To leverage this, we first define the map function, then we write the map template, then we ]
nb[ write flatmap as a substitution over the definition of 'map'. ]

= ':* [? [:: :* ^2 [.] %% 02 [00 01 00] ^1 [:^]] [%v] :? %1]

nb[ List append. ]
nb[ Appends each element from the second list to the first. The head of :+ x y is the head of y. Here are the cases: ]

nb[ | :+ _ :: t h -> :: :+ _ t h ]
nb[   :+ x []     -> x ]

= ':+ [? [:: :+ ^1 [:^]] [%v %s] :? %1]

nb[ List length. ]
nb[ This is the usual recursive length function over lists. ]

= ':# [? [+ 01 :# :t] [00 %v] :? %0]

nb[ List access. ]
nb[ This function gives you the nth element, where 0 is the head (last element) of the list. If you request something beyond the end of the list, this function pushes [] onto the stack. ]

nb[ | :@ n :: x y -> :@ (n-1) x ]
nb[   :@ 0 :: x y -> y ]
nb[   :@ n [] _   -> [] ]

= ':@ [? [? [:@ - 01 ^1 [:t]] [:h %v] :? %0] [%v] %0]

nb[ Cons accessors. ]
nb[ These retrieve the individual pieces of a cons cell. :! conses an object to nil if it is not already a cons. : is a unary 'return' function for the list monad. ]

= ':! [? [] [:] :? %0]
= ':h [%v :^]
= ':t [%% 02 [00] :^]

= ': [:: []]

nb[ Generated by SDoc ]
