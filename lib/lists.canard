nb[ Canard standard library: list functions | Spencer Tipping]
nb[ Licensed under the terms of the MIT source code license]

nb[ Introduction.]
nb[ This library defines useful list functions, including map, flatmap, filter, append, etc. All traversal goes from right to left, as per the natural cons cell ordering.]

nb[ Flatmap definition.]
nb[ Flat-map is structured just like map. The only difference is that the intermediate results are appended rather than consed. Also, it needs to make a recursive call to itself rather than to the]
nb[ map function.]

= ':~ :** [:*] :+ s/ ':* [':~] s/ ':: [':+] @ ':*

nb[ Search/replace.]
nb[ This is a simple piecewise function that preserves all symbols except for the one being sought. If that one is encountered, an alternative is returned:]

nb[ | . s/ 'a [b] 'a -> b]
nb[   . s/ 'a [b] 'c -> 'c]

nb[ This function builds a closure by consing up a list with wildcards. Here's the derivation:]

nb[ | s/ a [b] -> [? [b %v] [] $= 'a]]
nb[   :+ [?] :: [] :+ %s [%v] :: [] %s         a b           = [? [b %v]] a]
nb[   :+ %^ 1 [:+ :+ [[] $=] %s [%0] :: [] $:] [? ['b %v]] a = [? [b %v] [] $= 'a %0]]

= 's/ [:+ %^ 1 [:+ :+ [[] $=] %s [%0] :: [] $:] :+ [?] :: [] :+ %s [%v] :: [] %s]

nb[ Recursive combinator.]
nb[ Recursively descends throughout a list; useful for doing search/replace on chunks of code. This is also templated to support flat-mapping recursively; as such, it is a transformation of the]
nb[ block given to a map or flat-map function. Here are the cases:]

nb[ | :** [map] [f] :: x y -> map [:** [map] [f]] :: x y]
nb[   :** [map] [f] _      -> f _]

nb[ You can use it like this: :* :** [:*] [+ 1] [1 2 [3 4] 5], yielding [2 3 [4 5] 6].]

= ':** [? [. ^1 [:: :: :: [] ':**] %0] [. %v] :? %2]

nb[ Map-function template.]
nb[ Here is the derivation for flatmap:]

nb[ | :~ [f] :: x y -> :+ :~ [f] x f y]
nb[   ^1 [:^]      [f] :: x y  = [f] x y]
nb[   %% 2 [0 1 0] [f] x y     = [f] x [f] y]
nb[   ^2 [.]       [f] x [f] y = [f] x f y]
nb[   :+ :~        [f] x f y   = :+ :~ [f] x f y]

nb[ Notice, however, that a number of functions here can be replaced to do other things. For instance, the :+ invocation in flatmap can be replaced with ::, at which point the function will be a]
nb[ regular map. What we really have is a 'map template' that can be specialized in different ways. To leverage this, we first define the map function, then we write the map template, then we]
nb[ write flatmap as a substitution over the definition of 'map'.]

= ':* [? [:: :* ^2 [.] %% 2 [0 1 0] ^1 [:^]] [%v] :? %1]

nb[ List append.]
nb[ Appends each element from the second list to the first. The head of :+ x y is the head of y. Here are the cases:]

nb[ | :+ _ :: t h -> :: :+ _ t h]
nb[   :+ x []     -> x]

= ':+ [? [:: :+ ^1 [:^]] [%v %s] :? %1]

nb[ List length.]
nb[ This is the usual recursive length function over lists.]

= ':# [? [+ 1 :# :t] [0 %v] :? %0]

nb[ Cons accessors.]
nb[ These retrieve the individual pieces of a cons cell.]

= ':h [%v :^]
= ':t [%% 2 [0] :^]

nb[ Generated by SDoc ]
