nb[ Binary emitters | Spencer Tipping ]
nb[ Licensed under the terms of the MIT source code license ]

nb[ Introduction. ]
nb[ These are a series of functions that allow you to represent numbers in various ways, most importantly in hexadecimal and binary. Rather than doing anything particularly creative, I'm just ]
nb[ building up custom entries in the main symbol table. There are 256 for each of hexadecimal and binary: ]

nb[ | b00000000 ]
nb[   b00000001 ]
nb[   b00000010 ]
nb[   b00000011 ]
nb[   ... ]
nb[   b11111111 ]
nb[   x00 ]
nb[   x01 ]
nb[   x02 ]
nb[   ... ]
nb[   xff ]

nb[ Each of these just pushes the given number onto the stack; there is no runtime conversion. ]

nb[ Base conversion. ]
nb[ These functions convert decimal numbers to hex and binary, respectively. Each one operates on bytes and prepends zeroes to fill to eight bits. ]

= '#16 [nb #* 2 [^1 [$+ %s $ $^ %s '0123456789abcdef & 15 >>> * 4] %% 2 [1 0 1]] %s ']
= '#2  [nb #* 8 [^1 [$+ %s $ $^ %s '01               & 1  >>>]     %% 2 [1 0 1]] %s ']

nb[ | #b n -> nb #* b [block] n "" ]

nb[ | [block] i n s -> n ($+ %s ($ $^ %s 'alphabet & mask >>> i n) s) ]
nb[   %% 2 [1 0 1]                         i n s   = n i n s ]
nb[   ^1 [$+ $ $^ %s 'alphabet & mask >>>] n i n s = n ($+ %s ($ $^ %s 'alphabet & mask >>> i n) s)] ]

nb[ Numeric constant definitions. ]
nb[ This is simple enough. For each number, we just cons up that number to a list, convert the number to each base, and assign the function. ]
nb[ Generated by SDoc ]
