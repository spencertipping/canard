nb[ Canard standard library: function manipulation | Spencer Tipping ]
nb[ Licensed under the terms of the MIT source code license ]

nb[ Piecewise construction. ]
nb[ This serves the purpose of something like 'where' in functional languages. The idea is to provide a series of local definitions that will be inlined into the form in question. This is done ]
nb[ first by defining a substitution function, then deriving a recursive variant from that. ]

nb[ | :/ symbol replacement -> [? :: replacement '%v [] $= 'symbol %0] ]
nb[   %s $:                     symbol replacement                      = replacement 'symbol ]
nb[   :: %s ''%v                replacement 'symbol                     = (:: replacement '%v) 'symbol ]
nb[   ^1 [:: %s '%0 :: [[] $=]] (:: replacement '%v) 'symbol            = (:: replacement '%v) [[] $= 'symbol %0] ]
nb[   :+ [?] :+ :: []           (:: replacement '%v) [[] $= 'symbol %0] = [? (:: replacement '%v) [] $= 'symbol %0] ]

nb[ The :/ function constructs a closure, but does not actually perform substitution. To do that, you would use :*, :~, or :**. ]

= ':/ [:+ [?] :+ :: [] ^1 [:: %s '%0 :: [[] $=]] :: %s '%v %s $:]

nb[ Composition. ]
nb[ Functions can be composed by appending their list forms. . @o f g x is the same as f g x. ]

= '@o [:+ @: ^1 [@:]]

nb[ Objectification. ]
nb[ Functions can be objectified (converted to anonymous list form) by using @ on any symbols that are present. Lists pass through unmodified, since they are already functions. ]

= '@: [? [] [@] :? %0]

nb[ Recursive map. ]
nb[ Like the regular map function, but distributes over sub-lists recursively. This is primarily useful for editing functions in their list form. ]

nb[ | :** [f] :: x y -> :* [:** [f]] :: x y ]
nb[   :** [f] _      -> f _ ]

nb[ You can use it like this: :** [+ 1] [1 2 [3 4] 5], yielding [2 3 [4 5] 6]. ]

= ':** [? [:* :: :: [] ':**] [.] :? %1]

nb[ Generated by SDoc ]
