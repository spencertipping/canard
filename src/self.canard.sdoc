Algebraic definition of the language.
Because immutable cons cells are the only builtin reference type, we can easily
specify the structural properties of a canard executor. We also specify certain
cases in the fetch/decode cycle, prefixed here with `.:`.

| .:: = fetch/decode cons structure from top continuation
  .:" = fetch/decode string from top continuation
  .:@ = fetch/decode symbol from top continuation

In each of these cases we can encode "do something" by changing the
continuation stack, as we do with `.:@` to resolve symbols. Ultimately the only
thing Canard does is call native functions (which is hard-coded into the
interpreter, since it's just a single computed-goto).

As you might expect, all of these are specified in concatenative form against a
stack of quoted `d c r` values. All of the primitives at this level are
implemented in micro-canard.

| .:: (evaluate cons/string)
  .:: [*d] [*c0 [*c1 x]] r h         = [*d x] [*c0 [*c1]] r h
  :^ :^ s$ [*d] [*c0 [*c1 x]] r h    = x [*c1] [*c0] [*d] r h
  :: sr :: sr x [*c1] [*c0] [*d] r h = [*d x] [*c0 [*c1]] r h

| .:@ (evaluate symbol)
  .:@ [*d] [*c0 [*c1 x]] [*r r]               = [*d x] [*c0 [*c1] !. r] [r* r]
  :^ :^ s$ [*d] [*c0 [*c1 x]] [*r r]          = x [*c1] [*c0] [*d] [*r r]
  :: !. :: sr x [*c1] [*c0] [*d] [*r r]       = [*c0 [*c1] !.] x [*d] [*r r]
  :^ s$ sR :: sr [*c0 [*c1] !.] x [*d] [*r r] = r [*r] [*c0 [*c1] !.] [*d x]
  sr :: s$ sR r [*r] [*c0 [*c1] !.] [*d x]    = [*d x] [*c0 [*c1] !. r] [*r]

[:: sr :: sr :^ :^ s$                             .::]
[:: sr :: sr :^ :^ s$                             .:"]
[sr :: s$ sR :^ s$ sR :: sr :: '!. :: sr :^ :^ s$ .:@]

The `'!.` in the last equation means that we need a pre-resolved evaluator
native ref; if we did anything else we'd either leave the symbol's resolved
value on the data stack, or loop forever as we tried to resolve `.`.

  Metaprogramming primitives.
  Canard needs to provide special operations for the following functions:

  | .  = schedule for evaluation, or "push continuation"
    r< = data to resolver
    r> = data from resolver
    .< = data to continuations
    .> = data from continuations
    s< = unquote data stack
    s> = quote data stack

  Equations:

  | s$ :: s$ sR :^       [*d x] [*c] r h = [*d] [*c x] r h
    sr :^ s, sR          [*d x]    c r h = [*d]      c x h
    sR s$ sr :: sr s: sR [*d]      c r h = [*d r]    c r h
    s$ s, sR :^          [*d x]    c r h = [*d]      x r h
    :: sr s: s$          [*d]      c r h = [*d c]    c r h
    :: s:                [*d]      c r h = [*d [*d]] c r h
    s, s$ :^             [*d d]    c r h = d         c r h

  [s$ :: s$ sR :^        .]
  [sr :^ s, sR          r<]
  [sR s$ sr :: sr s: sR r>]
  [s$ s, sR :^          .<]
  [:: sr s: s$          .>]
  [:: s:                s>]
  [s, s$ :^             s<]

  Micro-canard.
  Micro-canard is a subset of canard that provides everything required to write
  programs that describe canard's semantics using term rewriting. It can also
  be implemented using preprocessor macros, which means it can be abstractly
  interpreted with zero runtime overhead.

  The reason we can write a self-describing language is that canard's stacks
  are themselves lists, which means we can have these primitives operate on
  quoted forms of the interpreter state.

  | ',  = pre-resolved native nil (not implemented below)
    '!. = pre-resolved native eval (not implemented below)
    ::  = cons
    :^  = uncons, or mnemonically, "cons invert"
    s$  = swap
    s,  = drop
    s:  = dup
    sr  = rotate 3 left  (i.e. sr 1 2 3 = 2 3 1)
    sR  = rotate 3 right (i.e. sR 1 2 3 = 3 1 2)

  Equations:

  | :: :: sR :^ s$ :^                   [*d [*t] h] c r h = [*d [*t h]] c r h
    :: s$ :: sr :^ :^                   [*d [*t h]] c r h = [*d [*t] h] c r h
    :: s$ :: sr s$ sR :^ s$ :^          [*d y x]    c r h = [*d x y]    c r h
    s, :^                               [*d x]      c r h = [*d]        c r h
    :: s$ :: sr s: :^                   [*d x]      c r h = [*d x x]    c r h
    :: s$ :: s$ :: s$ sr :^ sr :^ s$ :^ [*d x y z]  c r h = [*d z x y]  c r h
    :: s$ :: sR :: sR s$ :^ s$ :^ s$ :^ [*d x y z]  c r h = [*d y z x]  c r h

  [:: :: sR :^ s$ :^                   ::]
  [:: s$ :: sr :^ :^                   :^]
  [:: s$ :: sr s$ sR :^ s$ :^          s$]
  [s, :^                               s,]
  [:: s$ :: sr s: :^                   s:]
  [:: s$ :: s$ :: s$ sr :^ sr :^ s$ :^ sr]
  [:: s$ :: sR :: sR s$ :^ s$ :^ s$ :^ sR]

  Strings and the heap.
  Canard has an abstraction for mutable strings, which are reference types and
  behave like aliasable `unsigned char*` pointers in C. Unlike in C, each
  string has an immutable length assigned when it's created.

  Strings matter and have these semantics because we can quote the heap into a
  string alias and use normal string functions on it. This means we can specify
  the internals of things like `cons`, etc, by expressing them in string
  operations against a quoted heap. As usual, this is done in micro-canard.

  A few things to consider here:

  | 1. You can resize the heap by returning a different string.
    2. Any unerased conses you create will modify the heap in place.
    3. Micro-canard also needs to be able to do math.

  Note that nothing about heap quoting requires that strings be mutable; when
  you're writing abstract interpreters you can do things like journaling
  instead. The downside there is that you'll need a separate heap, which
  complicates things. This implementation mutates in place so you can easily
  implement a garbage collector in micro-canard.

  Preprocessor micro-canard abstract evaluator.
  The evaluator contains some logic to avoid intermediate cons cell allocation;
  this ends up being useful for JIT, where we want to minimize garbage. `cons`,
  `h`, and `t` must not be preprocessor macros for this to work.

  The macro names here are based on canard's packed-symbol encoding and aren't
  meant to be human-readable. This is a recurring theme in canard.

  Note that `_2e2127` is a bit of a hack to enable micro-canard programs to
  insert references to the native evaluator function. Otherwise we'd be unable
  to write the symbol resolver using micro-canard, at which point the language
  would be little more than a bizarre joke.

  Also note that compilers will need to add wrapping `ev()` calls, one for each
  micro-canard primitive command. The alternative is to use a preprocessor
  multiplier to get a bunch of them, but this will slow down JIT cycles since
  we'll be making the preprocessor do a bunch of extra work.

["#EOF
#define paste(x, y) x##y

#define hd_cons(t, h) h
#define tl_cons(t, h) t

#define hd_d h(d)
#define tl_d t(d)
#define hd_c h(c)
#define tl_c t(c)
#define hd_r h(r)
#define tl_r t(r)

#define hd_h(x) h(h(x))
#define tl_h(x) t(h(x))
#define hd_t(x) h(t(x))
#define tl_t(x) t(t(x))

#define hd(x) paste(hd_, x)
#define tl(x) paste(tl_, x)

#define _2c(...)            (__VA_ARGS__)
#define _2c27(...)          (0, __VA_ARGS__)
#define _2e2127(...)        (_eval_i, __VA_ARGS__)
#define _3a3a(h, t, ...)    (cons(t, h), __VA_ARGS__)
#define _5e3a(x, ...)       (hd(x), tl(x), __VA_ARGS__)
#define _2473(x, y, ...)    (y, x, __VA_ARGS__)
#define _2c73(x, ...)       (__VA_ARGS__)
#define _3a73(x, ...)       (x, x, __VA_ARGS__)
#define _7273(x, y, z, ...) (y, z, x, __VA_ARGS__)
#define _5273(x, y, z, ...) (z, x, y, __VA_ARGS__)

#define commit(dn, cn, rn, ...) \
  do { \
    ref const _d = (dn); \
    ref const _c = (cn); \
    ref const _r = (rn); \
    d = _d; \
    c = _c; \
    r = _r; \
    goto fetch_next; \
  } while (0)

#define mc(f) commit f(d, c, r, STACK_END)
#define ev(x) x
EOF mc]

C source.
We need some boilerplate around the generated definitions (partially just to
make those definitions more compact). We also need compiling alternatives to
certain low-level primitives so we can evaluate into a JIT context.

  Interpreter state.
  All interpreter state is memory-mapped so we can forward it across a JIT
  cycle (thus requiring JIT to be closed under memory-layout specifics; i.e. no
  distributed heap forwarding/sharing, not that I was especially tempted). Type
  tags:

  | (0 << 30) = fn     (immediate)
    (1 << 30) = isym   (immediate)
    (2 << 30) = cons   (reference)
    (3 << 30) = string (reference)

  Nil (`_2c`) is always encoded as a fn at index 0; this enables it to function
  as C-false, which improves execution efficiency a bit.

["#EOF
#define _POSIX_C_SOURCE 200112L
#define _XOPEN_SOURCE   600
#define _ISOC99_SOURCE
#define _ISOC9X_SOURCE
INCLUDES

typedef unsigned long ref;
struct cons { ref h; ref t; };

static ref d, c, r;
static unsigned char *h0, *hp;

#define type(v) ((v) >> 30)
#define val(v)  ((v) & 0x3fffffffl)
MC_DEFS

static inline ref h(ref const c) {return ((struct cons*)(h0 + val(c)))->h;}
static inline ref t(ref const c) {return ((struct cons*)(h0 + val(c)))->t;}
static inline ref cons(ref const tl, ref const hd)
{
  struct cons *r = (struct cons*) hp;
  hp += sizeof(struct cons);
  r->t = tl;
  r->h = hd;
  return (unsigned char*) r - h0 | 2l << 30;
}

int main(int argc, char **argv)
{
  ref n;
  void *const *const fns[]   = { &&_2c, FN_LABELS };
  void *const *const cases[] = { &&_213a2e, &&_403a2e, &&_3a3a2e, &&_223a2e };

  ref _eval_i = 0;
  for (; fns[_eval_i] != &&_2e; ++_eval_i);

  /* TODO: bootup continuation/resolver/etc */

fetch_next:
  for (n = 0; !n;) n = h(c), c = t(c);
  if (type(n) == 2) c = cons(c, t(n)), n = h(n);
  goto *cases[type(n)];
_213a2e: goto *fns[n];
_2c: goto fetch_next;
FNS
}
EOF c]

POSIX shell wrapper.
This is responsible for compiling and executing the above C code. Nothing too
special; we just forward any command-line options. All canard-related state is
baked into the C source.

["#EOF
#!/bin/sh
t=${TMPDIR:-/tmp}
i=0
until mkdir "$t/canard-$i" 2>/dev/null; do
  i=$((i + 1))
done
cat > "$t/canard-$i/canard.c" <<'_'
C_SOURCE
_
c99 "$t/canard-$i/canard.c" $CANARD_C99_OPTS -o "$t/canard-$i/canard" \
  && exec "$t/canard-$i/canard" "$@"
EOF sh]
