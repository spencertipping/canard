Algebraic definition of the language.
Because immutable cons cells are the only builtin reference type, we can easily
specify the structural properties of a canard executor. We also specify certain
cases in the fetch/decode cycle, prefixed here with `.:`.

| .:: = fetch/decode cons structure from top continuation
  .:" = fetch/decode string from top continuation
  .:@ = fetch/decode symbol from top continuation

In each of these cases we can encode "do something" by changing the
continuation stack, as we do with `.:@` to resolve symbols. Ultimately the only
thing Canard does is call native functions (which is hard-coded into the
interpreter, since it's just a single computed-goto).

As you might expect, all of these are specified in concatenative form against a
stack of quoted `d c r` values. All of the primitives at this level are
implemented in micro-canard.

| .:: (evaluate cons/string)
  .:: [*d] [*c0 [*c1 x]] r         = [*d x] [*c0 [*c1]] r
  :^ :^ s$ [*d] [*c0 [*c1 x]] r    = x [*c1] [*c0] [*d] r
  :: sr :: sr x [*c1] [*c0] [*d] r = [*d x] [*c0 [*c1]] r

| .:@ (evaluate symbol)
  .:@ [*d] [*c0 [*c1 x]] [*r r]               = [*d x] [*c0 [*c1] !. r] [r* r]
  :^ :^ s$ [*d] [*c0 [*c1 x]] [*r r]          = x [*c1] [*c0] [*d] [*r r]
  :: !. :: sr x [*c1] [*c0] [*d] [*r r]       = [*c0 [*c1] !.] x [*d] [*r r]
  :^ s$ sR :: sr [*c0 [*c1] !.] x [*d] [*r r] = r [*r] [*c0 [*c1] !.] [*d x]
  sr :: s$ sR r [*r] [*c0 [*c1] !.] [*d x]    = [*d x] [*c0 [*c1] !. r] [*r]

[:: sr :: sr :^ :^ s$                             .::]
[:: sr :: sr :^ :^ s$                             .:"]
[sr :: s$ sR :^ s$ sR :: sr :: '!. :: sr :^ :^ s$ .:@]

The `'!.` in the last equation means that we need a pre-resolved evaluator
native ref; if we did anything else we'd either leave the symbol's resolved
value on the data stack, or loop forever as we tried to resolve `.`.

Micro-canard.
Micro-canard is a subset of canard that provides everything required to write
programs that describe canard's semantics using term rewriting. It can also be
implemented using preprocessor macros, which means it can be abstractly
interpreted with zero runtime overhead.

The reason we can write a self-describing language is that canard's stacks are
themselves lists, which means we can have these primitives operate on quoted
forms of the interpreter state.

| :: = cons
  :^ = uncons, or mnemonically, "cons invert"
  s$ = swap
  s, = drop
  s: = dup
  sr = rotate 3 left  (i.e. sr 1 2 3 = 2 3 1)
  sR = rotate 3 right (i.e. sR 1 2 3 = 3 1 2)

Equations:

| :: :: sR :^ s$ :^                   [*d [*t] h] c r = [*d [*t h]] c r
  :: s$ :: sr :^ :^                   [*d [*t h]] c r = [*d [*t] h] c r
  :: s$ :: sr s$ sR :^ s$ :^          [*d y x]    c r = [*d x y] c r
  s, :^                               [*d x]      c r = [*d] c r
  :: s$ :: sr s: :^                   [*d x]      c r = [*d x x] c r
  :: s$ :: s$ :: s$ sr :^ sr :^ s$ :^ [*d x y z]  c r = [*d z x y] c r
  :: s$ :: sR :: sR s$ :^ s$ :^ s$ :^ [*d x y z]  c r = [*d y z x] c r

[:: :: sR :^ s$ :^                   ::]
[:: s$ :: sr :^ :^                   :^]
[:: s$ :: sr s$ sR :^ s$ :^          s$]
[s, :^                               s,]
[:: s$ :: sr s: :^                   s:]
[:: s$ :: s$ :: s$ sr :^ sr :^ s$ :^ sr]
[:: s$ :: sR :: sR s$ :^ s$ :^ s$ :^ sR]

  Preprocessor micro-canard abstract evaluator.
  The evaluator contains some logic to avoid intermediate cons cell allocation;
  this ends up being useful for JIT, where we want to minimize garbage. `cons`,
  `h`, and `t` must not be preprocessor macros for this to work.

  The macro names here are based on canard's packed-symbol encoding and aren't
  meant to be human-readable. This is a recurring theme in canard.

  Note that _2e2127 is a bit of a hack to enable micro-canard programs to
  insert references to the native evaluator function. Otherwise we'd be unable
  to write the symbol resolver using micro-canard, at which point the language
  would be little more than a misguided joke.

["#EOF
#define paste(x, y) x##y

#define hd_cons(t, h) h
#define tl_cons(t, h) t
#define hd(x) paste(hd_, x)
#define tl(x) paste(tl_, x)

#define _3a3a(h, t, ...)    (cons(t, l), __VA_ARGS__)
#define _5e3a(x, ...)       (h(x), t(x), __VA_ARGS__)
#define _2473(x, y, ...)    (y, x, __VA_ARGS__)
#define _2c73(x, ...)       (__VA_ARGS__)
#define _3a73(x, ...)       (x, x, __VA_ARGS__)
#define _7273(x, y, z, ...) (y, z, x, __VA_ARGS__)
#define _5273(x, y, z, ...) (z, x, y, __VA_ARGS__)

#define _2e2127(...) (1, __VA_ARGS__)

#define commit(d, c, r) \
  do { \
    ref const _d = (d); \
    ref const _c = (c); \
    ref const _r = (r); \
    d = _d; \
    c = _c; \
    r = _r; \
  } while (0)

#define mc(f) commit f(d, c, r)
#define ev(x) x
EOF]

Core primitives.
In two groups: non-stack and stack-related. Canard needs to provide special
operations for the following functions:

| .  = schedule for evaluation, or "push continuation"
  r< = data to resolver
  r> = data from resolver
  .< = data to continuations
  .> = data from continuations
  s< = unquote data stack
  s> = quote data stack

Equations:

| s$ :: s$ sR :^       [*d x] [*c] r = [*d] [*c x] r
  sr :^ s, sR          [*d x]    c r = [*d] c x
  sR s$ sr :: sr s: sR [*d]      c r = [*d r] c r
  s$ s, sR :^          [*d x]    c r = [*d] x r
  :: sr s: s$          [*d]      c r = [*d c] c r
  :: s:                [*d]      c r = [*d [*d]] c r
  s, s$ :^             [*d d]    c r = d c r

[s$ :: s$ sR :^        .]
[sr :^ s, sR          r<]
[sR s$ sr :: sr s: sR r>]
[s$ s, sR :^          .<]
[:: sr s: s$          .>]
[:: s:                s>]
[s, s$ :^             s<]

C source.
We need some boilerplate around the generated definitions (partially just to
make those definitions more compact). We also need compiling alternatives to
certain low-level primitives so we can evaluate into a JIT context.

  Interpreter state.
  All interpreter state is memory-mapped so we can forward it across a JIT
  cycle (thus requiring JIT to be closed under memory-layout specifics; i.e. no
  distributed heap forwarding/sharing, not that I was especially tempted). Type
  tags:

  | (0 << 30) = fn     (immediate)
    (1 << 30) = isym   (immediate)
    (2 << 30) = cons   (reference)
    (3 << 30) = string (reference)

  Nil is always encoded as a fn at index 0; this enables it to function as
  C-false, which improves execution efficiency a bit.

["#EOF
#define _POSIX_C_SOURCE 200112L
#define _XOPEN_SOURCE   600
#define _ISOC99_SOURCE
#define _ISOC9X_SOURCE

#include <sys/types.h>
#include <string.h>
INCLUDES

typedef unsigned long ref;
typedef struct { ref h; ref t; } cons;

static ref d, c, r;
static unsigned char *h, *hp;

#define type(v) ((v) >> 30)
#define val(v)  ((v) & 0x3fffffffl)
MC_DEFS

static inline ref h(ref const c) {return ((const const*) (h + val(c)))->h;}
static inline ref t(ref const c) {return ((const const*) (h + val(c)))->t;}

static inline ref cons(ref const tl, ref const hd)
{
  cons *r = hp;
  hp += sizeof(cons);
  r->t = tl;
  r->h = hd;
  return r - h | 2l << 30;
}

int main(int argc, char **argv)
{
  void *const *const fns[]   = { FN_LABELS };
  void *const *const cases[] = { &&_213a2e, &&_403a2e, &&_3a3a2e, &&_223a2e };

  /* TODO: bootup continuation/resolver/etc */

fetch_next:
  ref n;
  for (n = 0; !n;) n = h(c), c = t(c);
  if (type(n) == 2) c = cons(c, t(n)), n = h(n);
  goto *cases[type(n)];

_213a2e: goto *fns[n];
_403a2e: EVAL_SYMBOL;
_3a3a2e: EVAL_CONS;
_223a2e: EVAL_STRING;
FNS
}
EOF c]

POSIX shell wrapper.
This is responsible for compiling and executing the above C code. Nothing too
special; we just forward any command-line options. All canard-related state is
baked into the C source.

["#EOF
#!/bin/sh
t=${TMPDIR:-/tmp}
i=0
until mkdir "$t/canard-$i" 2>&/dev/null; do
  i=$((i + 1))
done
cat > "$t/canard-$i/canard.c" <<'_'
C_SOURCE
_
c99 "$t/canard-$i/canard.c" $CANARD_C99_OPTS -o "$t/canard-$i/canard" \
  && exec "$t/canard-$i/canard" "$@"
EOF sh]
