#!/usr/bin/canard

nb [Shebang line definition
    We define the word #!/usr/bin/canard to be a no-op so that it's possible to
    use this at the top of scripts.]

    def '#!/usr/bin/canard []

nb [Reflection
    These functions are used to manipulate Java objects using the reflection
    API. Later on we'll have a way to generate proxy access classes that do this
    work much more efficiently, but in order to define those we need some way to
    invoke methods using reflection.]

    def 'type ++ :: [] method 'getClass object [] [swap []]
    def 'object :: [] ' class 'java.lang.Object

nb [List functions
    The usual suspects: map, filter, flatmap, etc. We already have a working
    version of append from below, so we can skip that one. Here are the
    derivations:

    +* [f] (:: xs x) = :: (+* [f] xs) (f x)
    +* [f] []        = []

    +* = ? [inductive] [base] nip

      inductive       [f] (:: xs x) = :: (+* [f] xs) (f x)
        :^ swap       [f] (:: xs x) = xs x [f]
        ^2 [.] %32021 xs x [f]      = [f] xs (f x)
        :: +*         [f] xs (f x)  = :: (+* [f] xs) (f x)

      base   [f] [] = []
        drop [f] [] = []

    Here's filter:

    +/ = ? [inductive] [base] nip

      inductive   [f] (:: xs x) = ? [append] [no-append] (f x) [f] xs x
        :^ swap   [f] (:: xs x) = xs x [f]
        . %321201 xs x [f]      = (f x) [f] xs x

        append  [f] xs x = :: (+/ [f] xs) x
          :: +/ [f] xs x = :: +/ [f] xs x

        no-append [f] xs x = +/ [f] xs
          +/ %301 [f] xs x = +/ [f] xs

      base   [f] [] = []
        drop [f] [] = []

    And here's flatmap, which is identical to +* except for two names:

    +@ [f] (:: xs x) = ++ (+@ [f] xs) (f x)
    +@ [f] []        = []]

    def '+/ [? [? [:: +/] [+/ %301] . %321201 :^ swap] [drop] nip]
    def '+@ [? [++ +@ ^2 [.]          %32021  :^ swap] [drop] nip]
    def '+* [? [:: +* ^2 [.]          %32021  :^ swap] [drop] nip]

    def '::$ [:: swap]
    def ':^$ [swap :^]

nb [Stack shorthands
    These are more common names that can be used instead of cryptic %x
    functions. Most of the names come from Joy.]

    def 'dup  [%00]
    def 'drop [%1]
    def 'swap [%210]
    def 'nip  [%01]
    def 'rot< [%3120]
    def 'rot> [%3201]

nb [Resolution
    Sometimes it's useful to be able to resolve a variable without executing it.
    You can do this using the @? function.]

    def '@? [. @>]

nb [def and nb
    This is some of the most subtle and gnarly code in the entire Canard
    codebase. Most of the intricate complexity arises from the minimalism in
    Canard's evaluator/resolver design. Here's the story on that.

    Canard's semantics are deceptively simple. Lists can be interpreted, which
    entails evaluating the head and then interpreting the tail. If a list is
    evaluated (not interpreted), it simply pushes itself onto the data stack.
    If a symbol is evaluated, it resolves itself and pushes its resolution onto
    the return stack, which basically inserts a continuation.

    And that's about it. The resolver is a function like any other. Because cons
    and function application are the same thing and you can change the resolver,
    you end up defining new symbols by consing new things onto the system
    resolver and then installing the result as the system's resolver.

    Strangely enough, this fails miserably unless you are very careful. The
    failure case arises because lists are quoted by default -- so each symbol's
    resolution happens the first time it is evaluated. With that in mind,
    suppose you optimistically cons a list like this onto the resolver:

    [? ['value %2 r>] [] = 'foo %00]

    The next time you try to resolve a symbol, let's say 'foo, this list will be
    run. None of this is a problem until you hit %00. At this point, the
    resolver will be called again, this time to resolve %00. And your custom
    resolver code will be run again, and will call %00 again, etc.

    Ok ... so, in order to fix this, we have to make sure that all of the
    symbols inside a resolver are either (1) pre-resolved (I don't think this is
    possible, or if it is it's a lot of work), or (2) they get resolved before
    our resolver is called. The only way to make sure this will happen is to dig
    through the resolver list with a local fixed point, waiting until we hit a
    null entry. At that point we can put our additions onto the bottom of the
    list and re-cons the others above.

    Canard doesn't provide a catch-all resolver in the bootstrap layer, so our
    new resolvers can be inserted at the end of the resolver list. Most
    recursion will probably be done through the symbol table, but at this point
    we don't have that to work with. So right now we need to create an ad-hoc
    fixed point. Here's what the append function looks like:

    ++ [++] [xs ... x] [ys ... y] = :: (++ [++] [xs ... x] [ys ...]) y
    ++ [++] [] y                  = y

    Here's the derivation for the nontrivial case:

    ++           [++] xs (:: ys y) = :: (++ [++] xs ys) y
    :^ %3201     [++] xs (:: ys y) = ys y [++] xs
    :: . %422301 ys y [++] xs      = :: . [++] [++] xs ys y

    The trivial case:

    ++  [++] x [] = x
    %31 [++] x [] = x

    The decision just needs to check the ys list for nullness. Here's the
    complete append function, wrapped so that it pushes [++] automatically:

    :: :: [.] %00 [? [:: . %422301 :^ %3201] [%31] %02]

    The append function is the first piece, but we also need a way to build a
    closure that acts as a resolver function. Each piece of the resolver list is
    a function that either matches and returns early, or fails to match and
    follows its given continuation. Specifically:

    . [continuation match]  's = 'v
    . [continuation reject] 's = . [continuation] 's

    The mechanics of this involve using r> to pop [continuation] from the return
    stack. If we want to push 'v, then, we'd do this:

    . [continuation 'v %2 r>] 's = 'v

    So in general, matching takes the form [%3x r>]. Rejecting a match is
    usually just [] or [%x]. Here's the derivation for a general-purpose symbol
    match closure:

    continuation match 's 'v 's = 'v
    continuation match 's 'v 'x = continuation 'x

    [? [%31 r>] [%1] = %102] 's 'v 'x
      [%31 r>] 'v 'x = 'v
      [%1] 'v 'x     = 'x

    Closing over 's and 'v is just a matter of quote-consing them onto the list.
    Here's what that looks like:

    :: :: [? [%31 r>] [%1] = %102] ' 's 'v

    Now we can put these pieces together to define '->', a preliminary function
    that defines a matcher:

    @< . %02 . %01 '-> [:: :: ... '] @> [++]
         |     |       |                |
         ------+-------+----------------+
               +-------+

    After this runs, we'll still have [++] on the stack to reuse for the next
    few definitions.

    Defining 'def' is straightforward enough. We just need to move the arguments
    to the right places. Specifically:

    def 'name [value] = @< ++ -> 'name [value] @>
    @< ++ %210 @> -> 'name [value] = @< ++ (-> 'name [value]) @>

    We also define nb[] here so that we can write this comment.]

    def 'nb [%1]

    %1 @< ++       -> 'def [@< ++ %210 @> ->]                    @>
       @< . %02    -> '++ %01                                    @>
       @< . %02 . %01 '-> [:: :: [. [? [%31 r>] [%1] = %102]] '] @>

       :: :: [.] %00 [? [:: . %422301 :^ %3201] [%31] %02]
